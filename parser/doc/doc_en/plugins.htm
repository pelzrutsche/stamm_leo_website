{PROJECT}		../../template/doc.en.ini
{GRAFIK_LINKS}	$home/gifs/li_phpcms.gif
{LOGO_1}		$home/gifs/cmslogo1.gif
{LOGO_2}		$home/gifs/cmslogo2.gif
{MENU}			00.08.10.07
{TITEL}			Plugins for phpCMS
{PLUGIN FILE="$home/doc/doc_en/time_user.php" TYPE="DYNAMIC"}

{CONTENT}
This section is (mainly) for developers. If you do not count yourself in this category you may simply go on reading the other sections of the manual. <b>Detailed knowledge of plug-ins is not needed in order to use phpCMS!</b>
<ul>
<li><a href="$self#beschr">Description of Plug-Ins</a></li>
<li><a href="$self#temp">Use of plug-ins in template files</a></li>
<li><a href="$self#content">Use of plug-ins in content files</a></li>
<li><a href="$self#variablen">Accessing variables</a></li>
<li><a href="$self#beispiel">An example</a></li>
</ul>
<p>&nbsp;</p><hr />
<US><a name="beschr"><a href="$self#top">Description of Plug-Ins</a></a></US>
<p>
Plug-ins provide an interface to, and closer integration with, phpCMS' core functions. Output generated by scripts included via &#123;SCRIPT&#125; is sent directly to the browser. Plug-ins, on the other hand, are implemented in a way that allows to store values and results for later use, either during or after parsing, or to alter values in a document.
</p>
<p>
Advantages of plug-ins vs. included scripts
<ul>
<li>(static)  output can be cached.</li>
<li>(static) output can be g-zipped.</li>
<li>Fields in a content document can be altered at runtime.</li>
<li>Global settings, like duration of proxy and client caching, can be change on a per page basis.</li>
<li>Can be included in both template and content files.</li>
<li>Allow use of server headers.</li>
</ul>
Disadvantages of plug-ins vs. included scripts
<ul>
<li>Custom scripts need more adjustment.</li>
<li>Requires deeper knowledge of PHP, caching, and phpCMS.</li>
<li>Although global variables can be read, &#36;GLOBALS[] must be used to create new ones, since plug-ins are executed within a function, while scripts are executed in PHP's global scope.</li>
<li>No partial caching of pages, as is possible with included scripts.</li>
</ul>
</p>
<p>In case you wrote your own plug-ins for phpCMS that may be of interest to others, please send them in. I will publish them with due credits to the author on www.phpCMS.de.
</p>
<p><hr /></p>
<US><a name="temp"><a href="$self#top">Use of plug-ins in template files</a></a></US>
<p>Plug-ins embedded in a template will be executed in every page generated from that template. Plug-ins are thus useful for things like displaying the creation date of a page, or creating keywords for meta tags.
<br /><br />Plug-ins are executed in the exact location and order within the template they are embedded in. If, for example, you are using a plug-in to change certain tags within a template, and you write the plug-in towards the end of the template, only those tags will be affected that are come after the plug-in.
</p>
<p>
This is how plug-ins are <b>embedded into a template</b>:
</p>
<BLOCKQUOTE>&#123;PLUGIN FILE="path_to_plugin/plugin.php" TYPE="DYNAMIC"&#125;</BLOCKQUOTE>
<p>The keyword &#8220;FILE&#8221; describes the path to where the plug-in is located in your file system. The path to the plug-in may be specified either</p>
<ul>
<li>using the "&#36;home" variable</li>
<li>relative to the location of the template</li>
<li>or as an absolute path, where &#8220;absolute&#8221; means starting from the server root.</li>
</ul>

<p>The keyword &#8220;TYPE&#8221; specifies whether the plug-in needs to be executed each time the page is served. Possible values are &#8220;DYNAMIC&#8221; and &#8220;STATIC&#8221;. A plug-in specified as &#8220;DYNAMIC&#8221; will be executed each time the page is requested by a browser. Neither the client nor any proxy server will be permitted to cache its output. Caching behavior can be controlled directly in the plug-in. A &#8220;STATIC&#8221; plug-in, on the other hand, will be executed only the first time the page is requested, and its output may then be cached together with the rest of the page. Caching behavior in this case  follows the settings globally defined in phpCMS.
</p>

<p>The values of both &#8220;FILE&#8221; and &#8220;TYPE&#8221; need to be within &#34;straight&#34; quotation marks.
</p>
<p>Any output of a plug-in will be inserted where the plug-in is located within the template, and may only be written to the plug-in buffer.
</p>
<p><hr /></p>
<US><a name="content"><a href="$self#top">Use of plug-ins in content files</a></a></US>
<p>The advantage of embedding plug-ins in content files is that this can be done on a per page basis. This may also free you of the need to define a special template for that plug-in. Another advantage of this is that plug-ins will be executed <b>before</b> the document is processed further. At this time the content file has already been read by phpCMS but no tags have been replaced, nor have the menus and the template(s) been processed.
</p>
<p>Embedding plug-ins into content files works the same as has been described for templates above, only this time it is <b>embedded into a content file</b>.
</p>
<p>If a plug-in produces any output, the output must be stored in the plug-in buffer. In order for this to work, we need to define a substitute within the template which will later be replaced by the plug-in's output:
</p>
<BLOCKQUOTE>&#123;CONTENT_PLUGIN_0&#125;</BLOCKQUOTE>
<p>Each plug-in is given a number in the order of its appearance within the content file, starting with zero (0). The substitute starts with the keyword "CONTENT_PLUGIN_" followed by the number given to the plug-in.
</p>
<p>If a plug-in does not produce any output, or if its function is restricted to changing the contents of another field within the content file, no substitute keyword needs to be placed into the template. In this case the plug-in will be executed nonetheless.
</p>
<p>If within the template there is a substitute keyword representing a plug-in, but no plug-in is embedded into the content file, the substitute keyword in the template will be ignored. This means there is no problem with defining a plug-in substitute within your standard template even thought the plug-in is embedded (and executed) only in certain content files.
</p>

<p><hr /></p>
<US><a name="variablen"><a href="$self#top">Accessing variables</a></a></US>
<p>Plug-ins can access all variables present in the parser's global scope. This includes any variables sent to a page using the GET or POST methods, HTTP_COOKIE_VARS, etc.
</p>
<p>In addition to this, plug-ins can access, and modify, the following variables supplied by the parser:
<BLOCKQUOTE>
<b>&#36;PageContent</b>
<p>All of the content file's content. The variable is an ARRAY of ARRAY of STRING.  You can access individual content fields within the content file by using their respective field names.
<br /><br />If, for example, you have a field called &#123;TITLE&#125; in your content file, you can access the first line of the contents of this field using: "&#36;PageContent-&gt;TITLE[0]". <b>NOTE:</b> all fields are treated as arrays even though they may contain only a single value.
</p>

<b>&#36;CacheState</b>
<p>Used to manage caching behavior within phpCMS. This variable is a STRING that can take on a value of either "on" or "off". If the variable is set to "on", the content of a document will be cached internally after being parsed by phpCMS. If it is set to "off", it will not be committed to phpCMS's internal cache.
<br /><br /><b>NOTE</b> though: if another document with the same name is allready stored in the cache, that document will not be deleted and replaced automatically! Therefore, if e.g. you make changes to a template by adding a plug-in to it, you need to flush the cache afterwards. Otherwise the changes you've made will not show in the pages served off the cache.
</p>

<b>&#36;ClientCache</b>
<p>Used to manage behavior of proxy servers and client cache. This variable is a STRING that can take on a value of either "on" or "off". If set to "on", both proxy and client caching are enabled, otherwise they are disabled.
</p>

<b>&#36;ProxyCacheTime</b>
<p>This variable is a STRING. Its content is added to the current time and signifies when a page that may be cached by proxy servers or the client should again be retrieved from your server. Caching duration is expressed in seconds. In this example, client caching is to expire after one day:
<BLOCKQUOTE>
&#36;ProxyCacheTime = <b>1</b> * 60 * 60 * 24
</BLOCKQUOTE>
</p>

<b>&#36;Tags</b>
<p>This variable is an ARRAY of ARRAYS of STRINGS. It contains all tags you have defined within your tag file along with the ones supplied by phpCMS. It can be used to add tags, or to change existing tags:
<BLOCKQUOTE>
&#36;Tags[counter][0] = value to be replaced;<br />
&#36;Tags[counter][1] = substitute value;
</BLOCKQUOTE>
"Counter" denotes the numbering of tags in you tags file.
</p>

<b>&#36;PluginBuffer</b>
<p>This variable is an ARRAY of STRING. The plugin-in buffer serves to store the output of a plug-in, and to hand it over to phpCMS. If only a single value is handed over, you still need to write to the first element of the array. When using plug-ins in a template, the location of the substitute keyword (with the appropriate numering) determines where in the template the contents of the plug-in buffer are handed over. The same applies to the output of plug-ins used within a content file respectively.
</p>

<b>&#36;CHECK_PAGE->path</b>
<p>Signifies the path of the file being parsed, relative to the server root.
</p>

<b>&#36;CHECK_PAGE->name</b>
<p>
Signifies the name of the file being parsed.
</p>

</BLOCKQUOTE>
Functions supplied by phpCMS that can be used with plug-ins:
<BLOCKQUOTE>
<b>string = &#36;PHP->GetDocRoot()</b>
<p>This gives you the root directory of the server running phpCMS. I wrote this functions after I noticed that the environmental variable &#36;DOCUMENT_ROOT does not point to the server root in all cases.
</p>

<b>string = &#36;PHP->Version(&#36;number)</b>
<p>This gives you the version number of PHP running on your server, where &#36;number can be 1,2,3 or 4, and specifies the position within the version string. Thus if you had PHP version 4.0.2pl1 on your server, &#36;PHP->Version(1) would return "4". &#36;PHP->Version(4) would return "pl1". This function is not yet supported in PHP3.
</p>

<b>string = &#36;PHP->API()</b>
<p>This returns "mod" if PHP is run as server API. If PHP is run as CGI this function returns "cgi".
</p>

<b>string = &#36;PHP->OS()</b>
<p>Your server's operating system. Returns "win" for Windows or "nix" for Unix or Linux. Returns an empty string when neither of these OS's is being used.

</p>
</BLOCKQUOTE>
<p>So, if you wanted to access the file currently being parsed, to get its path and name you might write:

<BLOCKQUOTE>
&#36;File = &#36;PHP->GetDocRoot().'/'.&#36;CHECK_PAGE->path.'/'.&#36;CHECK_PAGE->name;
</BLOCKQUOTE>
</p>
<p><hr /></p>
<US><a name="beispiel"><a href="$self#top">An example</a></a></US>
<p>In this example we are going to build a plug-in that prints 
out the visitor's IP number and time of visit.
A substitute keyword is written into the template so that the plug-in is 
executed only on those pages that have the plug-in embedded in their 
content file.
The tags <i>&lt;!-- PLUGIN:TIME_USER time --&gt;</i> and 
<i>&lt;!-- PLUGIN:TIME_USER ip --&gt;</i> get replaced.
</p>
<p>
<b>Template:</b>
<hr /><CODE><PRE>
&lt;html&gt;
&lt;body&gt;
&#123;MENU NAME="MAIN"&#125;
&lt;h1&gt;Heading&lt;/h1&gt;
&#123CONTENT&#125;
&lt;/body&gt;
&lt;/html&gt;
</PRE></CODE>
<hr /><br />
<b>Content file:</b>
<hr />
<CODE><PRE>
&#123;PROJECT&#125; /wherever/project.ini
&#123;MENU&#125; 00.01.01
&#123;PLUGIN FILE="/wherever/time_user.php" TYPE="DYNAMIC"&#125;
&#123;CONTENT&#125;
The current time is &lt;!-- PLUGIN:TIME_USER time --&gt;.
You have the IP number &lt;!-- PLUGIN:TIME_USER ip --&gt;.
</PRE></CODE>
<hr /><br />
<b>PLUGIN (time_user.php):</b>
<hr />
<CODE><PRE>
&lt;?
$current = count($Tags);
$Tags[$current][0] = '&lt;!-- PLUGIN:TIME_USER time --&gt;';
$Tags[$current][1] = date ( "H:i" , time () );
$Tags[$current+1][0] = '&lt;!-- PLUGIN:TIME_USER ip --&gt;';
$Tags[$current+1][1] = $REMOTE_ADDR;
?&gt;
</PRE></CODE>
<hr /></p>
<p>
This should produce the following on our page:
<BLOCKQUOTE>
The current time is <!-- PLUGIN:TIME_USER time -->.<br />
You have the IP number <!-- PLUGIN:TIME_USER ip -->.
</BLOCKQUOTE>
In case it's <!-- PLUGIN:TIME_USER time -->, and your IP number is <!-- PLUGIN:TIME_USER ip --> :-)
</p>
<p>
<b>NOTE:</b> There must not be any blank lines or spaces in front of the opening (&lt;?) of after the closing (?&gt;) PHP tag. Otherwise the parser would die with a nasty error message.
</p>
